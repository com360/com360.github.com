---
layout: post
title:  "网络性能优化：TCP优化"
date:   2016-05-31 21:35:31 +0800
categories: jekyll update
---
#### TCP

## TCP协议

Internet两个核心协议是IP（Internet Protocol)协议和TCP(Transimission Control Protocol)协议。IP协议提供提供主机到主机的路由和寻址；TCP提供在不可靠信道之上的抽象。

TCP提供的这种在不可靠信道上的网络通信，隐藏了通信的复杂细节。作为应用程序开发者来说是不需要处理这些操作,简化了应用程序的开发。但是如果能够了解TCP的原理和细节，对应用程序的网络优化将会有莫大的帮助。

TCP帮助应用层处理了数据丢失重传，数据发送顺序控制，拥塞控制，数据重组等。TCP保证了数据的顺序和完整性。

TCP的三次握手

所有的TCP连接，在传输应用数据之前都要进行一个三次握手的过程，进行关键信息的交换。

SYN    :客户端产生一个随机数x，再加上一些其他TCP参数，发送一个SYN包给服务端。

SYN ACK：服务端在对x加1，自己再产生一个随机数y，再加上一些其他TCP参数，返回给客户端。

ACK    ：客户端同时对x和y再加1，发送最后一个ACK包，完成握手过程。

>SYN:Synchronize sequence numbers,同步序列编号；
>
>ACK:Acknowledgment

请看下图：

![TCP Handshake]({{ site.url }}/assets/tcp_handshake.png)

只有完成三次握手之后才真正的开始传输数据。

大家可以看出，TCP握手要消耗1.5个RTT（Round Trip Time，客户端到服务端的一个来回），即1.5RTT的延迟。

大家了解了三次握手之后，就需要看看怎么针对性的进行优化了。

（1）大家知道客户端和服务端的距离越远，那么RTT的值会越大，即延迟会越长。那么在没有改变握手协议的情况下进行
缩短客户端和服务端的距离将会大大减少RTT的时间。有条件的公司尽量使得服务器离用户最近。

（2）握手协议优化：TFO

   TFO（TCP Fast Open），对之前的TCP握手进行了优化，在最后一次握手的时候，会把数据一起带过去，而不需要等等最后
   一次握手完成之后再进行传输数据。这样就减少了一个次RTT的延迟。不过TFO对要传输数据有一定的要求。

   Google的分析得出的结果：可以减少15%的网络延迟，整个页面加载时间平均减少10%，在一些场景下能减少高达40%的延迟。TFO是google提出的对TCP的优化，并在实践中率先使用。

   从Linux 3.7开始支持了TFO，建议服务器升级，减少TCP的网络延迟。

(3)TCP的连接重用
 
 通过上面的分析，TCP的建链成本非常高，对TCP的连接的重用是减少延迟的直接和重要的方式。做好连接重用机制，防止过多消耗服务器资源。


#### TCP拥塞的避免和控制机制

![TCP Congestion contral]({{ site.url }}/assets/hpbn_0203.png)

从上图可以看出，TCP每次传输的数据量的大小是递增的，而不是一下在就直接以最大的数据量传输。

TCP为什么会采用这种机制发送数据？

TCP的连接的两个端是无法知道它所在的网络带宽到底是多少，并且整个网络环境可能会时时的改变，如果网络环境不好，丢包重传的几率很大的话，在某些节点会等待丢失的数据重新传过来，会导致网络拥塞，无法继续进行数据传输，需要一种机制进行调节TCP每次发送的数据量，避免发生拥塞。

#### Head-of-Line Blocking

TCP发送的数据包是有序的，并且有重传机制，因为这个机制原因，在网络不稳定，丢包率大的情况下，容易出现Head-of-Line Blocking。举个例子，发送了三个有序的数据包，前两个传过去了，第一个丢失了，TCP会把前两个缓存起来，等待第一个重传的数据包，如果总是失败，那么就堵塞在那里。这个TCP基本上是无法避免的。

#### slow-start 和 拥塞避免

TCP通信不知道网络带宽是多少，如果想要知道带宽是多少只能依靠测量。在三次握手的过程中，客户端和服务端双方会协商开始交换数据的时候采用的流量大小是多少，这个协商的结果和ACK包一起发送。我们把协商的大小称作Congestion window size (cwnd)，这个值是由服务端决定，此值由操作系统设定。

>Congestion window size (cwnd):这个值限制了发送方每次发送的数据量，在ACK握手期间决定初始大小，在传输过程中时时调整。

TCP发送数据采用先慢后快的算法进行数据传输的，并且会根据网络状况时时改变cwnd大小（避免拥塞）。

![拥塞控制公式]({{ site.url }}/assets/cwnd001.png)

开始的时候的使用小的拥塞窗口大小，每一次来回，增加一倍大小。通过上面的公式进行计算经过多少时间可以达到最优的数据大小。

通过公式很容易的可以计算，达到最优的cwnd大小需要多长时间，这个时间距离越远，越明显。和带宽几乎没有关系。

拥塞的初始化窗口大小的值比较小，是因为TCP的传输的特点是可靠的有序的传输，如果刚开始就以很大的数开始，在网络状况比较差的情况，直接会产生拥塞，数据发送的第一次RTT的时间会非常的长；

要想减少拥塞控制的时间，可以通过如下几个方面考虑：

增加初始的拥塞窗口大小：通过上面的公式可以看出，初始大小越大，达到最佳的拥塞窗口大小，用的时间越少。建议升级服务器操作系统版本，新版的Linux的系统已把这个大小提高的4segment,而早期的只有1segment。

减少slow-start次数：使用TCP的长连接，不需要再次进行slow-start。

使用TCP Fast Open:在三次握手的最后一次握手进行数据传输和slow-start计算，减少一次RTT。

不传输数据是最快的：尽量减少不必要的数据传输，甚至不传数据。

减少RTT的时间很重要的一个方式是使用CDN（内容分发网络），把静态资源缓存到最近的分发网络上，减少用户访问的时间。


###### 参考

[1] [Diffie–Hellman key exchange](https://en.wikipedia.org/wiki/Diffie–Hellman_key_exchange)

[2] [High Performance Browser Networking](http://chimera.labs.oreilly.com/books/1230000000545)
